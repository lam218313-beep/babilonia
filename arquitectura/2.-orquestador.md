Documento de Arquitectura de Software Módulo 02: El Orquestador Dinámico (The Dynamic Orchestrator) Versión: 1.0 Patrón de Diseño: Agentic Workflow / State Machine / Factory Pattern Función Principal: Planificación Estratégica, Gestión de Dependencias y Supervisión de Calidad.
1. Visión General El Orquestador es la entidad autoritaria del sistema. A diferencia de un chatbot convencional, este módulo tiene persistencia de estado (recuerda el progreso del proyecto a lo largo de meses) y capacidad de autocrítica.
Su arquitectura se divide en dos fases temporales distintas:
Fase de Génesis: Un "Meta-Agente" diseña al gerente ideal para el proyecto.
Fase de Ejecución (Runtime): La instancia del gerente opera el flujo de trabajo (Workflow).
2. Fase I: La Fábrica de Agentes (Genesis Engine) Este sub-módulo se ejecuta una sola vez al inicio de cada proyecto. Su objetivo es resolver la "Paradoja del Conocimiento": configurar un sistema experto antes de empezar.
Componentes: The Profiler (Perfilador):
Input: Prompt del usuario (ej. "Hospital II-1 en Cusco"). El input señalado, en un escenario realista sería un TDR (Términos de Referencia) Documento contractual estándar donde señalan los requisitos específicos de contratación.
Acción: Interroga al Motor 1 (Data Core) para extraer:
Lista de entregables obligatorios (BIM Uses).
Normativa crítica (Restricciones "Hard").
Flujo de trabajo recomendado.
The Compiler (Compilador de Prompt):
Acción: Redacta el System Prompt maestro. Inyecta las "Reglas de Oro" específicas.
Ejemplo de Regla Inyectada: "Bajo ninguna circunstancia aprobarás un plano de arquitectura sin validación térmica previa, debido a la ubicación en zona de heladas (Cusco)."
The Roadmap Generator:
Acción: Genera el Grafo Acíclico Dirigido (DAG) inicial. Define los 40+ nodos (tareas) y sus flechas de dependencia.
3. Fase II: La Maquina de Estados (Runtime Instance) Una vez nacido, el Orquestador se convierte en una Máquina de Estados Finita (FSM) que gestiona el ciclo de vida del expediente.
Componentes del Runtime: 3.1. Gestor de Grafos (DAG Manager) Es el motor que mueve el proyecto hacia adelante.
Lógica: No es lineal (1, 2, 3). Es topológica.
Funcionamiento:
Evalúa el estado de todos los nodos.
Identifica nodos READY (aquellos cuyas dependencias padres están COMPLETED).
Despacha los nodos READY al Motor 3 (Modulador) y Motor 4 (Ejecutor).
Bloquea ramas del árbol si un nodo crítico falla (ej. Si "Estudio de Suelos" falla, bloquea "Cálculo de Cimientos").
3.2. Supervisor de Coherencia (The Reviewer) Es el filtro de calidad. Ningún entregable pasa a "Finalizado" sin su firma.
Input: Entregable generado por el Ejecutor (ej. Plano JSON, Memoria Word).
Validación Cruzada:
Consulta al Motor 1 (Data Core) para verificar cumplimiento normativo.
Consulta su propia Memoria de Estado para verificar consistencia interna (ej. "¿El área construida en este plano coincide con el cuadro de áreas aprobado hace 2 semanas?").
Decision Logic:
Pass: Marca nodo como COMPLETED.
Fail: Marca nodo como REVISION_NEEDED y devuelve feedback detallado al Ejecutor.
3.3. Memoria de Estado (The Project Context) El cerebro a largo plazo.
State DB: Guarda variables globales del proyecto (Niveles de piso, Grillas, Materiales definidos).
Artifact Pointer: No guarda los archivos pesados (RVT, PDF), sino punteros/links a donde están almacenados, vinculándolos al nodo del grafo correspondiente.
4. Flujo de Datos (Data Flow) - Ejemplo "Runtime" Activación: El DAG detecta que el nodo TAREA_15: Diseno_Zapatas tiene sus dependencias satisfechas.
Despacho:
El Orquestador envía la orden al Motor 3 (Modulador): "Necesito el formato y normas para Zapatas".
Recibe el paquete del Modulador y lo envía al Motor 4 (Ejecutor): "Llena este formato usando estos datos del proyecto".
Recepción: El Ejecutor devuelve: Resultado_Zapatas_v1.json.
Auditoría:
El Supervisor lee Resultado_Zapatas_v1.json.
Detecta anomalía: "La profundidad es 1.0m, pero el Estudio de Suelos (Nodo 04) pedía mínimo 1.5m".
Rechazo: El Orquestador cambia el estado de la tarea a REJECTED y envía el error al Ejecutor para re-intento.
5. Stack Tecnológico Sugerido Orchestration Framework: LangGraph (Python). Es ideal porque permite definir grafos cíclicos (para los loops de corrección) y persistencia de estado nativa.
Database (Estado): PostgreSQL (con extensión JSONB para guardar el estado flexible del grafo).
LLM (Brain): Gemini 1.5 Pro. Se requiere ventana de contexto larga (1M+ tokens) para mantener en memoria el resumen de todas las decisiones anteriores del proyecto.
Interfaz de Control: API REST para que el Frontend pueda consultar el estado del grafo ("¿En qué porcentaje vamos?", "¿Qué tarea está bloqueada?").
6. Integración Crítica El Orquestador NO sabe dibujar ni sabe el formato de una memoria descriptiva. Solo sabe qué se necesita y cuándo.
Para el "Cómo" (Formato), depende del Motor 3.
Para el "Hacer" (Ejecución), depende del Motor 4.