Documento Maestro de Arquitectura de SoftwareProyecto: Sistema Multi-Agente para Expedientes Técnicos BIM (BIM-AI)Versión: 1.0 (Consolidada)Paradigma: Sistema Multi-Agente Jerárquico (Hierarchical Multi-Agent System) con RAG Nativo (File Search).
1. Visión Holística del Sistema
El software no es una herramienta lineal simple, sino un Ecosistema de Agentes Especializados. La arquitectura se basa en la Segregación de Responsabilidades Cognitivas:Separamos el Saber (Data Core) del Planificar (Orquestador).Separamos el Estandarizar (Modulador) del Ejecutar (Ejecutor).Separamos la Lógica Abstracta de la Implementación de Software (Facilitador).El sistema opera bajo un ciclo de "Planificación Dinámica → Ejecución Restringida → Validación Cruzada".
2. Topología de los 5 MotoresMotor 01: El Núcleo de Datos (The Knowledge Vault)Rol: La Biblioteca y Fuente de Verdad.Infraestructura: Google Vertex AI + Gemini File Search.Interacción: Pasiva (Responde a consultas).Conexión: Alimenta al Orquestador (para Metodología), al Modulador (para Normativa) y al Ejecutor (para Datos Específicos).Motor 02: El Orquestador Dinámico (The Manager)Rol: El Estratega y Gestor de Estado.Infraestructura: LangGraph (State Machine) + PostgreSQL.Interacción: Activa (Da órdenes).Meta-Característica: Se "auto-construye" al inicio del proyecto basado en el Data Core. Mantiene el Grafo de Dependencias (DAG) del proyecto.Motor 03: El Modulador (The Profiler)Rol: El Estandarizador.Infraestructura: Template Engine (Jinja2) + Pydantic.Interacción: Intermedia (Prepara el terreno).Salida: "Paquetes de Ejecución" (Plantilla vacía + Reglas estrictas + Ejemplos).Motor 04: El Ejecutor (The Worker)Rol: El Operario Intelectual.Infraestructura: LLM Chain-of-Thought (Gemini 1.5 Flash/Pro).Interacción: Operativa (Resuelve tareas atómicas).Lógica: Lineal y secuencial. No planifica, solo obedece el paquete del Modulador.Motor 05: El Facilitador (The Bridge)Rol: El Traductor de Código.Infraestructura: Code-LLM + Sandbox de Validación.Interacción: Final (Salida al usuario).Salida: Scripts (Python/Dynamo), Archivos (IFC/CSV) para consumo externo.3. El Bus de Comunicación (The Neural Pathway)Los motores no se envían correos electrónicos; se comunican mediante objetos JSON estrictos. Definimos el objeto clave que viaja por el sistema: el Payload de Tarea.JSON// Estructura del Objeto que viaja del Motor 2 -> 3 -> 4 { "task_id": "T-15", "task_type": "CALCULO_ESTRUCTURAL", "context_snapshot": { "project_location": "Cusco", "soil_type": "Rocoso" }, "constraints": { // Inyectado por Motor 3 (Modulador) "min_concrete_strength": "210 kg/cm2", "required_format": "Table_Type_A" }, "template": "<raw_jinja_template>", // Inyectado por Motor 3 "output_data": null // A ser llenado por Motor 4 } 4. Flujo de Vida del Proyecto (End-to-End Workflow)Fase A: El Bootstrapping (Génesis)Usuario: "Quiero un Hospital en Lima".Motor 1 (Data Core): Provee las reglas de juego para Hospitales.Motor 2 (Orquestador): Nace una instancia especializada. Crea un Grafo de 40 nodos.Fase B: El Ciclo de Producción (Repetitivo)El Orquestador detecta que el nodo "Cimentación" está listo.Orquestador → Modulador: "Dame el kit para Cimentación de Hospital".Modulador:Consulta al Data Core: "¿Norma de cimientos hospitales?".Prepara Plantilla + Norma Filtrada.Envía Paquete al Ejecutor.Ejecutor:Razona. Calcula. Consulta al Data Core si duda.Llena la Plantilla.Devuelve JSON_Cimentacion al Orquestador.Orquestador:Valida consistencia.Aprueba la tarea.Fase C: La MaterializaciónUsuario: "Descargar script para Revit".Orquestador: Envía el JSON_Cimentacion aprobado al Facilitador.Facilitador: Escribe código Python para Dynamo.Usuario: Recibe archivo .py.5. Diagrama de Infraestructura (Cloud Deployment)Para que esto funcione en la nube (Google Cloud Platform), la arquitectura física propuesta es:Frontend (UI): React/Next.js (Streamlit para prototipo).API Gateway: Gestiona las peticiones del usuario y protege el sistema.Contenedores (Cloud Run):Service A: Orquestador + Modulador (Lógica de negocio).Service B: Ejecutor + Facilitador (Workers pesados).Persistencia:Cloud SQL (PostgreSQL): Para el estado del Grafo (Memoria del proyecto).Vertex AI: Para los modelos LLM y el Data Core (File Search).Redis: Para caché de normas frecuentes.6. Principios de Diseño CríticosInmutabilidad Normativa: El Ejecutor NUNCA decide la norma. La norma le es impuesta por el Modulador (quien la sacó del Data Core). Esto garantiza legalidad.Estado Atómico: Si el sistema se apaga hoy, mañana el Orquestador sabe exactamente que se quedó en el "Paso 14, al 50%".Human-in-the-Loop: En puntos críticos definidos por el Orquestador (ej. fin de Anteproyecto), el sistema se detiene y exige aprobación humana antes de continuar.