Documento de Arquitectura de Software Módulo 03: El Modulador (The Modulator) Versión: 1.0 Patrón de Diseño: Strategy Pattern / Template Method / Context Injector Función Principal: Estandarización de Entregables, Acotación de Contexto y Gestión de Formatos.
1. Visión General Si el Orquestador es el Gerente que dice "Qué hacer" y el Ejecutor es el Técnico que lo hace, el Modulador es el Ingeniero de Procesos.
Su misión es evitar el problema del "Lienzo en Blanco". A una IA (o a un humano) no se le dice "Haz una memoria de estructuras"; se le da una plantilla, una lista de normas aplicables y un ejemplo de éxito. El Modulador construye ese Paquete de Ejecución (Execution Payload).
2. Componentes Principales 2.1. El Perfilador de Proyecto (The Project Profiler) Este componente es el filtro inteligente que mencionaste para manejar la "granularidad normativa".
Función: Reduce el espacio de búsqueda. Convierte la normativa general del Data Core en restricciones específicas.
Lógica de Acotación:
Input: Tarea solicitada ("Diseño de Mezcla") + Ubicación ("Puno").
Proceso: Consulta al Data Core pero aplica filtros estrictos.
Output: No entrega el PDF de la norma E.060 completa. Entrega un extracto JSON: {"f'c_min": "210 kg/cm2", "tipo_cemento": "Tipo IP", "aditivo": "Incorporador de aire"}.
Valor: Evita que el Ejecutor tenga que leer 500 páginas para encontrar un dato de 3 líneas.
2.2. Registro de Plantillas Inteligentes (Smart Template Registry) No son simples documentos de Word vacíos. Son esquemas de datos tipados.
Formatos Soportados:
Jinja2 Templates (Textos): Para Memorias Descriptivas y Especificaciones Técnicas. Estructuran títulos, subtítulos y párrafos obligatorios.
Pydantic Models (Datos): Para cálculos y listas de elementos. Definen qué campos son obligatorios, tipos de datos (float, string) y validaciones (min/max).
Pseudo-Código (Scripts): Plantillas de scripts de Python para que el Facilitador no empiece a programar desde cero.
2.3. Inyector de "Few-Shot Examples" (The Example Bank) La IA funciona mejor cuando ve ejemplos. El Modulador mantiene una base de datos de "Entregables Perfectos" de proyectos anteriores.
Funcionamiento:
Si la tarea es "Metrado de Cimientos", el Modulador busca en su banco un CSV de metrados de cimientos validado y lo adjunta al paquete como referencia: "Mira, así es como queremos el formato de salida".
3. Flujo de Datos (Data Flow) Escenario: Tarea "Crear Especificaciones Técnicas de Ventanas" Solicitud: El Orquestador envía: {"tarea": "espec_tecnicas_ventanas", "tipo_proyecto": "Hospital"}.
Selección de Plantilla (Template Registry):
Recupera hospital_window_spec_template.md.
Esta plantilla tiene huecos (placeholders) para: Espesor, Tipo de Vidrio, Transmitancia Térmica.
Perfilado Normativo (Profiler):
El Modulador pregunta al Data Core: "Dame las restricciones de vidrio para Hospitales en Zona 4".
Recibe: "Vidrio Laminado obligatoria, espesor min 8mm".
Ensamblaje del Paquete (Execution Payload):
El Modulador crea un JSON que contiene:
Instrucción: "Completa esta plantilla."
Plantilla: El texto con huecos.
Contexto Estricto: "Debes usar Vidrio Laminado. Espesor >= 8mm."
Ejemplo: Un fragmento de especificación de otro hospital.
Entrega: Envía este paquete al Motor 4 (Ejecutor).
4. Stack Tecnológico Sugerido Gestión de Plantillas: Jinja2 (Estándar de industria para templating en Python).
Validación de Datos: Pydantic. Es vital. Permite definir estructuras de datos rigurosas. Si el Ejecutor intenta poner un texto en un campo numérico, Pydantic lo rechaza antes de que llegue al Orquestador.
Almacenamiento de Plantillas: Sistema de Archivos (Git-based). Esto permite versionar las plantillas ("Plantilla de Memoria v2.0").
5. Por qué este módulo es la clave de la Estandarización Sin el Modulador, cada vez que la IA genere un metrado, lo haría con columnas diferentes (veces "Largo/Ancho/Alto", veces "X/Y/Z"). El Modulador fuerza la estructura. Le dice al Ejecutor: "No seas creativo con el formato, sé creativo con el contenido. El formato es ESTE".